#!/usr/bin/env bash
# Purpose: Detach a Scaleway Flexible IP from the target server (post-VM hook).
# Expected input: OpenNebula-provided environment variables (VMID, NIC_ID, etc.) and base64 VM template via stdin.
# Expected output: No stdout on success; logs detachment workflow to /var/log/vnm/scw-flexip-post.log.
set -euo pipefail

LOG_TAG="scw-flexip-post[$$]"
TOKEN_FILE="{{ one_driver_token_path }}"
SERVER_ID_FILE="{{ one_driver_server_id_path | default('/var/lib/one/scw-server-id') }}"
API_ENDPOINT="{{ one_driver_fip_api_endpoint }}"
LOG_DIR="/var/log/vnm"
LOG_FILE="${LOG_DIR}/scw-flexip-post.log"

log() {
  local msg="$*"
  local timestamp
  timestamp="$(date -u '+%Y-%m-%dT%H:%M:%SZ')" || timestamp="unknown"
  mkdir -p "$LOG_DIR" 2>/dev/null || return 0
  printf '%s [%s] %s\n' "$timestamp" "$LOG_TAG" "$msg" >> "$LOG_FILE" 2>/dev/null || true
}

log "INFO: Starting driver v1.0.0-alpha1 (post-detach)"

## Extract received data
xml_content=$(base64 -d)
log "DEBUG: Raw data received from OpenNebula: $xml_content"


## Identify our Scaleway server by reading the ID from a file
log "INFO: Reading Server ID from file: '$SERVER_ID_FILE'"

# Check if file is readable first
[[ -r "$SERVER_ID_FILE" ]] || {
  log "ERROR: Server ID file '$SERVER_ID_FILE' is missing or unreadable. Aborting."
  exit 0
}

# Read content after check
SCW_ID_STRING="$(tr -d '\r\n' < "$SERVER_ID_FILE")"

# Split the string using '/' as a delimiter
ZONE="${SCW_ID_STRING%/*}"
SERVER_ID="${SCW_ID_STRING#*/}"

log "INFO: Zone identified from file: '$ZONE'"
log "INFO: Local server ID (SERVER_ID) identified from file: '$SERVER_ID'"

[[ -n "$SERVER_ID" ]]  || {
  log "ERROR: Failed to parse SERVER_ID from file '$SERVER_ID_FILE'. Content: '$SCW_ID_STRING'. Aborting."
  exit 0
}
[[ -n "$ZONE" ]]  || {
  log "ERROR: Failed to parse ZONE from file '$SERVER_ID_FILE'. Content: '$SCW_ID_STRING'. Aborting."
  exit 0
}

[[ -r "$TOKEN_FILE" ]] || {
  log "ERROR: Token file '$TOKEN_FILE' is missing or unreadable. Aborting."
  exit 0
}

log "INFO: Checking token content."
## Check token
TOKEN="$(tr -d '\r\n' < "$TOKEN_FILE")"
[[ -n "$TOKEN" ]] || {
  log "ERROR: Token file is empty. Aborting."
  exit 0
}

log "INFO: Fetching IP (FIP_IP) from OpenNebula data..."
## Fetch the AR IP from OpenNebula input data
FIP_IP="$(echo "$xml_content" | xpath -e "//TEMPLATE/NIC[ATTACH]/IP/text()")"

log "INFO: IP (FIP_IP) extracted from data: '$FIP_IP'"

[[ -n "$FIP_IP" ]] || {
  log "ERROR: Could not extract IP (FIP_IP) from XML data. Aborting."
  exit 0
}

## Public IP Check
log "INFO: Checking if IP '$FIP_IP' is a public IP..."
IS_PUBLIC=true
case "$FIP_IP" in
    10.*)               # RFC1918 Class A
        IS_PUBLIC=false
        ;;
    172.1[6-9].* | \
    172.2[0-9].* | \
    172.3[0-1].*)       # RFC1918 Class B
        IS_PUBLIC=false
        ;;
    192.168.*)          # RFC1918 Class C
        IS_PUBLIC=false
        ;;
    127.*)              # Loopback
        IS_PUBLIC=false
        ;;
    169.254.*)          # Link-local
        IS_PUBLIC=false
        ;;
esac

if [[ "$IS_PUBLIC" == "false" ]]; then
  log "INFO: IP '$FIP_IP' is a private, loopback, or link-local address. Skipping FIP logic."
  exit 0 # Success, but nothing to do.
else
  log "INFO: IP '$FIP_IP' appears public. Proceeding with FIP logic."
fi

log "INFO: API call (GET fips) to list all FIPs and find ID..."
## Fetch the FIP ID
fip_resp="$(curl -sf -X GET -H "X-Auth-Token: $TOKEN" -H "Content-Type: application/json" "$API_ENDPOINT/zones/$ZONE/fips")" 

log "DEBUG: API response (GET fips): $fip_resp"

# Filter to find our IP
FIP_ID="$(echo "$fip_resp" | jq -