#!/usr/bin/env bash
# Purpose: Attach a Scaleway Flexible IP to the target server prior to OpenNebula bridge setup.
# Expected input: OpenNebula-provided environment variables (VMID, NIC_ID, etc.) and base64 VM template via stdin.
# Expected output: No stdout on success; logs attachment workflow to /var/log/vnm/scw-flexip-pre.log.
set -euo pipefail

LOG_TAG="scw-flexip-pre[$$]"
TOKEN_FILE="{{ one_driver_token_path }}"
SERVER_ID_FILE="{{ one_driver_server_id_path | default('/var/lib/one/scw-server-id') }}"
API_ENDPOINT="{{ one_driver_fip_api_endpoint }}"
LOG_DIR="/var/log/vnm"
LOG_FILE="${LOG_DIR}/scw-flexip-pre.log"

log() {
  local msg="$*"
  local timestamp
  timestamp="$(date -u '+%Y-%m-%dT%H:%M:%SZ')" || timestamp="unknown"
  mkdir -p "$LOG_DIR" 2>/dev/null || return 0
  printf '%s [%s] %s\n' "$timestamp" "$LOG_TAG" "$msg" >> "$LOG_FILE" 2>/dev/null || true
}

log "INFO: Starting driver v1.0.0-alpha1 (pre-attach)"

## Extract received data
xml_content=$(base64 -d)
log "DEBUG: Raw data received from OpenNebula: $xml_content"


## Identify our Scaleway server by reading the ID from a file
log "INFO: Reading Server ID from file: '$SERVER_ID_FILE'"

# Check if file is readable first
[[ -r "$SERVER_ID_FILE" ]] || {
  log "ERROR: Server ID file '$SERVER_ID_FILE' is missing or unreadable. Aborting."
  exit 0
}

# Read content after check
SCW_ID_STRING="$(tr -d '\r\n' < "$SERVER_ID_FILE")"

# Split the string using '/' as a delimiter
ZONE="${SCW_ID_STRING%/*}"
SERVER_ID="${SCW_ID_STRING#*/}"

log "INFO: Zone identified from file: '$ZONE'"
log "INFO: Local server ID (SERVER_ID) identified from file: '$SERVER_ID'"

[[ -n "$SERVER_ID" ]]  || {
  log "ERROR: Failed to parse SERVER_ID from file '$SERVER_ID_FILE'. Content: '$SCW_ID_STRING'. Aborting."
  exit 0
}
[[ -n "$ZONE" ]]  || {
  log "ERROR: Failed to parse ZONE from file '$SERVER_ID_FILE'. Content: '$SCW_ID_STRING'. Aborting."
  exit 0
}

[[ -r "$TOKEN_FILE" ]] || {
  log "ERROR: Token file '$TOKEN_FILE' is missing or unreadable. Aborting."
  exit 0
}

log "INFO: Checking token content."
## Check token
TOKEN="$(tr -d '\r\n' < "$TOKEN_FILE")"
[[ -n "$TOKEN" ]] || {
  log "ERROR: Token file is empty. Aborting."
  exit 0
}

log "INFO: Fetching IP (FIP_IP) from OpenNebula data..."
## Fetch the AR IP from OpenNebula input data
FIP_IP="$(echo "$xml_content" | xpath -e "/VM/TEMPLATE/NIC/IP/text()")"

log "INFO: IP (FIP_IP) extracted from data: '$FIP_IP'"

[[ -n "$FIP_IP" ]] || {
  log "ERROR: Could not extract IP (FIP_IP) from XML data. Aborting."
  exit 0
}

## Public IP Check
log "INFO: Checking if IP '$FIP_IP' is a public IP..."
IS_PUBLIC=true
case "$FIP_IP" in
    10.*)               # RFC1918 Class A
        IS_PUBLIC=false
        ;;
    172.1[6-9].* | \
    172.2[0-9].* | \
    172.3[0-1].*)       # RFC1918 Class B
        IS_PUBLIC=false
        ;;
    192.168.*)          # RFC1918 Class C
        IS_PUBLIC=false
        ;;
    127.*)              # Loopback
        IS_PUBLIC=false
        ;;
    169.254.*)          # Link-local
        IS_PUBLIC=false
        ;;
esac

if [[ "$IS_PUBLIC" == "false" ]]; then
  log "INFO: IP '$FIP_IP' is a private, loopback, or link-local address. Skipping FIP logic."
  exit 0 # Success, but nothing to do.
else
  log "INFO: IP '$FIP_IP' appears public. Proceeding with FIP logic."
fi

log "INFO: API call (GET fips) to list all FIPs and find ID..."
## Fetch the FIP ID
fip_resp="$(curl -sf -X GET -H "X-Auth-Token: $TOKEN" -H "Content-Type: application/json" "$API_ENDPOINT/zones/$ZONE/fips")" 

log "DEBUG: API response (GET fips): $fip_resp"

# Filter to find our IP
FIP_ID="$(echo "$fip_resp" | jq -r --arg ip "$FIP_IP" '.flexible_ips[] | select(.ip_address == $ip) | .id // empty')"
log "INFO: Filtering: FIP_ID found for IP '$FIP_IP': '$FIP_ID'"

# If no FIP_ID, it's not a Flexible IP. Log and exit cleanly.
[[ -n "$FIP_ID" ]] || {
  log "INFO: FIP_ID not found for IP '$FIP_IP'. This is likely not a Flexible IP. Skipping."
  exit 0
}

log "INFO: API call (GET fips/$FIP_ID) to fetch FIP details..."
# Fetch FIP details (MAC and attached server)
info_json="$(curl -sf -H "X-Auth-Token: $TOKEN" "$API_ENDPOINT/zones/$ZONE/fips/$FIP_ID")" || {
  log "ERROR: Failed to fetch details for FIP_ID '$FIP_ID'. Aborting."
  exit 1
}

log "DEBUG: API response (GET fips/$FIP_ID): $info_json"

log "INFO: Extracting MAC address and current server..."
# Search for the mac_address, either at the root or under a 'flexible_ip' key
MAC_ADDR="$(echo "$info_json" | jq -r '.mac_address.mac_address // .flexible_ip.mac_address.mac_address // empty')"
log "INFO: MAC Address (MAC_ADDR) found: '$MAC_ADDR'"

# Search for the server_id, either at the root or under a 'flexible_ip' key
CURRENT_SERVER="$(echo "$info_json" | jq -r '.server_id // .flexible_ip.server_id // empty')"
log "INFO: Currently attached server (CURRENT_SERVER): '$CURRENT_SERVER'"

## Add a MAC address if missing
if [[ -z "$MAC_ADDR" || "$MAC_ADDR" == "null" ]]; then
  log "ACTION: No MAC found for '$FIP_ID'. Generating a new MAC..."
  mac_resp="$(curl -sf -X POST \
      -H "X-Auth-Token: $TOKEN" \
      -H "Content-Type: application/json" \
      -d '{"mac_type":"{{ one_driver_mac_type }}"}' \
      "$API_ENDPOINT/zones/$ZONE/fips/$FIP_ID/mac")" || {
    log "ERROR: Failed to generate MAC for FIP_ID '$FIP_ID'. Aborting."
    exit 1
    }
  log "DEBUG: API response (POST mac): $mac_resp"
  MAC_ADDR="$(echo "$mac_resp" | jq -r '.mac_address.mac_address // empty')"
  log "SUCCESS: New MAC generated: '$MAC_ADDR'"
fi


log "--- Starting attachment logic ---"
log "INFO: Target FIP_ID: '$FIP_ID'"
log "INFO: Target SERVER_ID: '$SERVER_ID'"
log "INFO: Current Server: '$CURRENT_SERVER'"

# Case 1: The IP is already attached to our server
if [[ "$CURRENT_SERVER" == "$SERVER_ID" ]]; then
  log "INFO: FIP '$FIP_ID' is already attached to the correct server ('$SERVER_ID'). No action needed."

# Case 2 & 3: The IP is free or attached to the wrong server
else
  # Step 1: Detach if the IP is currently attached somewhere
  if [[ -n "$CURRENT_SERVER" ]]; then
    log "WARNING: FIP '$FIP_ID' is attached to a different server ('$CURRENT_SERVER'). Detachment required."
    
    detach_endpoint="$API_ENDPOINT/zones/$ZONE/fips/detach"
    
    # Payload for detachment
    detach_payload=$(cat <<JSON
{
  "fips_ids": ["$FIP_ID"]
}
JSON
)
    
    log "ACTION: API call (POST $detach_endpoint) for FIP '$FIP_ID'..."
    # API call for detachment, capture response and HTTP code
    response_with_code=$(curl -s -X POST \
        -H "X-Auth-Token: $TOKEN" \
        -H "Content-Type: application/json" \
        -d "$detach_payload" \
        -w "\nHTTP_CODE:%{http_code}" \
        "$detach_endpoint")

    # Extract HTTP code and response body
    http_code=$(echo "$response_with_code" | tail -n1 | cut -d: -f2)
    response_body=$(echo "$response_with_code" | sed '$d') # Remove the last line (HTTP code)

    # Handle the response
    case "$http_code" in
        200|201|202|204) # OK, Created, Accepted, No Content
            log "SUCCESS: FIP '$FIP_ID' detached from '$CURRENT_SERVER'. (Code: $http_code)"
            log "DEBUG: API response (detach): $response_body"
            ;;
        *) # Handle all other errors
            log "ERROR: Detachment failed. HTTP code: $http_code."
            log "ERROR: API response: $response_body"
            exit 1
            ;;
    esac

  else
    log "INFO: FIP '$FIP_ID' is free and ready for attachment."
  fi

  # Step 2: Attach the FIP to our server
  log "ACTION: Attaching FIP '$FIP_ID' to server '$SERVER_ID'..."
  
  attach_endpoint="$API_ENDPOINT/zones/$ZONE/fips/attach"
  
  # Payload for attachment
  attach_payload=$(cat <<JSON
{
  "fips_ids": ["$FIP_ID"],
  "server_id": "$SERVER_ID"
}
JSON
)
  
  log "ACTION: API call (POST $attach_endpoint) for FIP '$FIP_ID'..."
  # API call for attachment, capture response and HTTP code
  response_with_code=$(curl -s -X POST \
      -H "X-Auth-Token: $TOKEN" \
      -H "Content-Type: application/json" \
      -d "$attach_payload" \
      -w "\nHTTP_CODE:%{http_code}" \
      "$attach_endpoint")

  # Extract HTTP code and response body
  http_code=$(echo "$response_with_code" | tail -n1 | cut -d: -f2)
  response_body=$(echo "$response_with_code" | sed '$d') # Remove the last line

  # Handle the response
  case "$http_code" in
      200|201) # OK or Created
          log "SUCCESS: FIP '$FIP_ID' attached to '$SERVER_ID'. (Code: $http_code)"
          log "DEBUG: API response (attach): $response_body"
          ;;
      *) # Handle all other errors
          log "ERROR: Attachment failed. HTTP code: $http_code."
          log "ERROR: API response: $response_body"
          exit 1
          ;;
  esac

fi

log "--- Attachment logic complete ---"
exit 0