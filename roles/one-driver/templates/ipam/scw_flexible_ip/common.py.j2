#!/usr/bin/env python3
# Purpose: Provide shared utilities for Scaleway Flexible IP IPAM scripts to interact with OpenNebula.
# Expected input: Helper functions consume base64-encoded XML payloads, API responses, and on-disk state files.
# Expected output: Returns parsed data structures, performs API side effects, and records events in /var/log/ipam/scw_flexible_ip.log.
import base64
import json
import os
import sys
import time
import fcntl
import pathlib
import urllib.request
import urllib.error
import ipaddress
from xml.etree import ElementTree as ET

LOGGER_TAG = "{{ one_driver_logger_tag }}"
TOKEN_PATH = "{{ one_driver_token_path }}"
STATE_PATH = "{{ one_driver_state_file }}"
STATE_LOCK_PATH = STATE_PATH + ".lock"
ZONE = "{{ one_driver_zone }}"
FIP_ENDPOINT = "{{ one_driver_fip_api_endpoint }}"
IPAM_NAME = "{{ one_driver_ipam_name }}"
DEFAULT_MASK = "{{ one_driver_network_mask }}"
DEFAULT_GATEWAY = "{{ one_driver_gateway }}"
DEFAULT_DNS = {{ one_driver_dns_servers | to_json }}
MAC_TYPE = "{{ one_driver_mac_type }}"
PROJECT_ID = "{{ one_driver_project_id }}"
LOG_DIR = "/var/log/ipam"
LOG_FILE = str(pathlib.Path(LOG_DIR) / "scw_flexible_ip.log")


def log(message):
    try:
        log_dir = pathlib.Path(LOG_DIR)
        log_dir.mkdir(parents=True, exist_ok=True)
        log_entry = f"{time.strftime('%Y-%m-%dT%H:%M:%S%z')} [{LOGGER_TAG}] {str(message)}\n"
        with open(LOG_FILE, "a", encoding="utf-8") as fh:
            fh.write(log_entry)
    except Exception:
        pass


def read_stdin_xml():
    data = sys.stdin.buffer.read()
    if not data:
        return None
    try:
        xml_bytes = base64.b64decode(data.strip())
    except Exception as exc:
        log(f"Failed to decode base64 payload: {exc}")
        return None
    try:
        return ET.fromstring(xml_bytes)
    except ET.ParseError as exc:
        log(f"Failed to parse XML payload: {exc}")
        return None


def get_text(element, path):
    target = element.find(path)
    if target is None or target.text is None:
        return None
    value = target.text.strip()
    return value or None


def read_token():
    token = os.environ.get("SCW_TOKEN")
    if token:
        return token.strip()
    try:
        with open(TOKEN_PATH, "r", encoding="utf-8") as fh:
            return fh.read().strip()
    except FileNotFoundError:
        log(f"Token file {TOKEN_PATH} missing")
    except Exception as exc:
        log(f"Failed to read token: {exc}")
    return ""


def api_request(method, path, token, payload=None, expected=(200, 204)):
    url = f"{FIP_ENDPOINT}{path}"
    headers = {
        "X-Auth-Token": token,
        "Content-Type": "application/json",
    }
    data = None
    if payload is not None:
        data = json.dumps(payload).encode("utf-8")
    request = urllib.request.Request(url, data=data, headers=headers, method=method)
    try:
        with urllib.request.urlopen(request, timeout=20) as response:
            if response.status not in expected:
                log(f"Unexpected status {response.status} for {url}")
                return None
            if response.length == 0:
                return None
            body = response.read()
            if not body:
                return None
            return json.loads(body.decode("utf-8"))
    except urllib.error.HTTPError as exc:
        try:
            body = exc.read().decode("utf-8")
        except Exception:
            body = ""
        log(f"HTTP error {exc.code} for {url}: {body}")
    except Exception as exc:
        log(f"Request failed for {url}: {exc}")
    return None


def list_flexible_ips(token):
    data = api_request(
        "GET",
        f"/zones/{ZONE}/fips?page_size=100",
        token,
        payload=None,
        expected=(200,),
    )
    if not data:
        return []
    return data.get("flexible_ips", [])


def generate_mac(token, fip_id):
    payload = {"mac_type": MAC_TYPE}
    data = api_request(
        "POST",
        f"/zones/{ZONE}/fips/{fip_id}/mac",
        token,
        payload=payload,
        expected=(200,),
    )
    if not data:
        return ""
    mac_info = data.get("mac_address") or {}
    return mac_info.get("mac_address") or ""


def detach_fip(token, fip_id):
    payload = {"fips_ids": [fip_id]}
    api_request(
        "POST",
        f"/zones/{ZONE}/fips/detach",
        token,
        payload=payload,
        expected=(200,),
    )


def create_flexible_ip(token, project_id, description=None):
    if not project_id:
        log("Project ID is not configured; cannot create Flexible IP")
        return {}

    payload = {"project_id": project_id}
    if description:
        payload["description"] = description

    data = api_request(
        "POST",
        f"/zones/{ZONE}/fips",
        token,
        payload=payload,
        expected=(200, 201),
    )
    if not data:
        return {}

    fip = data.get("flexible_ip") or data
    if not isinstance(fip, dict):
        return {}

    ip_cidr = fip.get("ip_address")
    ip_value = None
    if ip_cidr:
        try:
            ip_value = str(ipaddress.ip_interface(ip_cidr).ip)
        except ValueError:
            ip_value = None

    mac_info = fip.get("mac_address") or {}
    mac_value = mac_info.get("mac_address") or ""

    return {
        "id": fip.get("id"),
        "ip": ip_value,
        "mac": mac_value,
    }


def delete_fip(token, fip_id):
    if not fip_id:
        return
    api_request(
        "DELETE",
        f"/zones/{ZONE}/fips/{fip_id}",
        token,
        payload=None,
        expected=(204,),
    )


class StateManager:
    def __init__(self):
        self.path = pathlib.Path(STATE_PATH)
        self.lock_path = pathlib.Path(STATE_LOCK_PATH)
        self.state = {"reservations": {}}
        self.dirty = False
        self.fd = None

    def __enter__(self):
        self.lock_path.parent.mkdir(parents=True, exist_ok=True)
        self.path.parent.mkdir(parents=True, exist_ok=True)
        self.fd = os.open(str(self.lock_path), os.O_RDWR | os.O_CREAT, 0o640)
        fcntl.lockf(self.fd, fcntl.LOCK_EX)
        if self.path.exists():
            try:
                with open(self.path, "r", encoding="utf-8") as fh:
                    self.state = json.load(fh)
            except Exception:
                log(f"Failed to read state file {self.path}, resetting")
                self.state = {"reservations": {}}
        else:
            self.state = {"reservations": {}}
        return self

    def mark_dirty(self):
        self.dirty = True

    def save(self):
        self.path.write_text(json.dumps(self.state, indent=2), encoding="utf-8")

    def __exit__(self, exc_type, exc_val, exc_tb):
        try:
            if self.dirty:
                self.save()
        finally:
            if self.fd is not None:
                try:
                    fcntl.lockf(self.fd, fcntl.LOCK_UN)
                finally:
                    os.close(self.fd)
            self.fd = None

    def reservations(self):
        return self.state.setdefault("reservations", {})

    def reserve(self, ip, flex_id, mac):
        self.state.setdefault("reservations", {})[ip] = {
            "flexible_ip_id": flex_id,
            "mac": mac,
            "timestamp": time.time(),
        }
        self.mark_dirty()

    def release(self, ip):
        if ip in self.state.get("reservations", {}):
            self.state["reservations"].pop(ip, None)
            self.mark_dirty()

    def lookup_by_ip(self, ip):
        return self.state.get("reservations", {}).get(ip)

    def reserved_ids(self):
        return [
            entry.get("flexible_ip_id")
            for entry in self.state.get("reservations", {}).values()
            if entry.get("flexible_ip_id")
        ]


def parse_ar(ar_element):
    return {
        "type": get_text(ar_element, "TYPE"),
        "ip": get_text(ar_element, "IP"),
        "size": get_text(ar_element, "SIZE"),
        "network_address": get_text(ar_element, "NETWORK_ADDRESS"),
        "network_mask": get_text(ar_element, "NETWORK_MASK"),
        "gateway": get_text(ar_element, "GATEWAY"),
        "dns": get_text(ar_element, "DNS"),
    }


def parse_address(address_element):
    if address_element is None:
        return {}
    return {
        "ip": get_text(address_element, "IP"),
        "size": get_text(address_element, "SIZE"),
        "mac": get_text(address_element, "MAC"),
    }


def format_ar_output(ar_data):
    lines = []
    lines.append("AR = [")
    lines.append(f'  IPAM_MAD = "{IPAM_NAME}",')
    if ar_data.get("type"):
        lines.append(f'  TYPE = "{ar_data["type"]}",')
    if ar_data.get("ip"):
        lines.append(f'  IP = "{ar_data["ip"]}",')
    if ar_data.get("size"):
        lines.append(f'  SIZE = "{ar_data["size"]}",')
    if ar_data.get("network_address"):
        lines.append(f'  NETWORK_ADDRESS = "{ar_data["network_address"]}",')
    if ar_data.get("network_mask"):
        lines.append(f'  NETWORK_MASK = "{ar_data["network_mask"]}",')
    if ar_data.get("gateway"):
        lines.append(f'  GATEWAY = "{ar_data["gateway"]}",')
    dns_values = ar_data.get("dns_values") or []
    for dns_server in dns_values:
        lines.append(f'  DNS = "{dns_server}",')
    if lines[-1].endswith(","):
        lines[-1] = lines[-1][:-1]
    lines.append("]")
    return "\n".join(lines)


def build_network(ar):
    ip_text = ar.get("network_address") or ar.get("ip")
    mask_text = ar.get("network_mask") or DEFAULT_MASK
    if not ip_text:
        return None
    try:
        return ipaddress.ip_network((ip_text, mask_text), strict=False)
    except ValueError:
        return None


def select_flexible_ip(fips, reserved_ids, network=None, requested_ip=None):
    requested_addr = None
    if requested_ip:
        try:
            requested_addr = ipaddress.ip_address(requested_ip)
        except ValueError:
            requested_addr = None
    for fip in fips:
        status = fip.get("status")
        if status not in ("ready", "detaching"):
            continue
        if fip.get("server_id"):
            continue
        fip_id = fip.get("id")
        if not fip_id or fip_id in reserved_ids:
            continue
        ip_cidr = fip.get("ip_address")
        if not ip_cidr:
            continue
        try:
            ip_addr = ipaddress.ip_interface(ip_cidr).ip
        except ValueError:
            continue
        if requested_addr and ip_addr != requested_addr:
            continue
        if network and ip_addr not in network:
            continue
        mac_info = fip.get("mac_address") or {}
        mac = mac_info.get("mac_address") or ""
        return fip_id, str(ip_addr), mac
    return None, None, None
